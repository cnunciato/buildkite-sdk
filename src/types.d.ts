/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Agents = AgentsObject | AgentsList;
/**
 * Query rules to target specific agents in k=v format
 */
export type AgentsList = string[];
/**
 * A boolean expression that omits the step when false
 */
export type If = string;
/**
 * Array of notification options for this step
 */
export type BuildNotify = (
  | ("github_check" | "github_commit_status")
  | {
      email?: string;
      if?: If;
    }
  | {
      basecamp_campfire?: string;
      if?: If;
    }
  | {
      slack?:
        | string
        | {
            channels?: string[];
            message?: string;
            [k: string]: unknown;
          };
      if?: If;
    }
  | {
      webhook?: string;
      if?: If;
    }
  | {
      pagerduty_change_event?: string;
      if?: If;
    }
  | {
      github_commit_status?: {
        /**
         * GitHub commit status name
         */
        context?: string;
      };
      if?: If;
    }
  | {
      github_check?: {
        /**
         * GitHub commit status name
         */
        context?: string;
        [k: string]: unknown;
      };
      if?: If;
    }
)[];
/**
 * Whether to proceed with this step and further steps if a step named in the depends_on attribute fails
 */
export type AllowDependencyFailure = true | false | "true" | "false";
/**
 * Which branches will include this step in their builds
 */
export type Branches = string | string[];
/**
 * The step keys for a step to depend on
 */
export type DependsOn =
  | null
  | string
  | (
      | string
      | {
          step?: string;
          allow_failure?: true | false | "true" | "false";
        }
    )[];
/**
 * A list of input fields required to be filled out before unblocking the step
 */
export type Fields = (
  | {
      /**
       * The text input name
       */
      text?: string;
      /**
       * The meta-data key that stores the field's input
       */
      key: string;
      /**
       * The explanatory text that is shown after the label
       */
      hint?: string;
      /**
       * The format must be a regular expression implicitly anchored to the beginning and end of the input and is functionally equivalent to the HTML5 pattern attribute.
       */
      format?: string;
      /**
       * Whether the field is required for form submission
       */
      required?: true | false | "true" | "false";
      /**
       * The value that is pre-filled in the text field
       */
      default?: string;
    }
  | {
      /**
       * The text input name
       */
      select?: string;
      /**
       * The meta-data key that stores the field's input
       */
      key: string;
      /**
       * The value of the option(s) that will be pre-selected in the dropdown
       */
      default?: string | string[];
      /**
       * The explanatory text that is shown after the label
       */
      hint?: string;
      /**
       * Whether more than one option may be selected
       */
      multiple?: true | false | "true" | "false";
      /**
       * @minItems 1
       */
      options: [
        {
          /**
           * The text displayed on the select list item
           */
          label: string;
          /**
           * The value to be stored as meta-data
           */
          value: string;
          /**
           * The text displayed directly under the select field’s label
           */
          hint?: string;
          /**
           * Whether the field is required for form submission
           */
          required?: true | false | "true" | "false";
        },
        ...{
          /**
           * The text displayed on the select list item
           */
          label: string;
          /**
           * The value to be stored as meta-data
           */
          value: string;
          /**
           * The text displayed directly under the select field’s label
           */
          hint?: string;
          /**
           * Whether the field is required for form submission
           */
          required?: true | false | "true" | "false";
        }[]
      ];
      /**
       * Whether the field is required for form submission
       */
      required?: true | false | "true" | "false";
    }
)[];
/**
 * A unique identifier for a step, must not resemble a UUID
 */
export type Key = string;
/**
 * The instructional message displayed in the dialog box when the unblock step is activated
 */
export type Prompt = string;
/**
 * Pauses the execution of a build and waits on a user to unblock it
 */
export type StringBlockStep = "block";
/**
 * Pauses the execution of a build and waits on a user to unblock it
 */
export type StringInputStep = "input";
/**
 * The paths for the caches to be used in the step
 */
export type Cache =
  | string
  | string[]
  | {
      paths: string[];
      size?: string;
      name?: string;
      [k: string]: unknown;
    };
/**
 * Whether to cancel the job as soon as the build is marked as failing
 */
export type CancelOnBuildFailing = true | false | "true" | "false";
/**
 * The label that will be displayed in the pipeline visualisation in Buildkite. Supports emoji.
 */
export type Label = string;
export type MatrixElement = string | number | boolean;
/**
 * Whether this step should be skipped. Passing a string provides a reason for skipping this command
 */
export type Skip = boolean | string;
/**
 * The conditions for marking the step as a soft-fail.
 */
export type SoftFail =
  | (true | false | "true" | "false")
  | {
      /**
       * The exit status number that will cause this job to soft-fail
       */
      exit_status?: "*" | number;
      [k: string]: unknown;
    }[];
/**
 * Waits for previous steps to pass before continuing
 */
export type StringWaitStep = "wait" | "waiter";

export interface JSONSchemaForBuildkitePipelineConfigurationFiles {
  env?: Env;
  agents?: Agents;
  notify?: BuildNotify;
  /**
   * A list of steps
   */
  steps: (
    | BlockStep
    | NestedBlockStep
    | StringBlockStep
    | InputStep
    | NestedInputStep
    | StringInputStep
    | CommandStep
    | NestedCommandStep
    | WaitStep
    | NestedWaitStep
    | StringWaitStep
    | TriggerStep
    | NestedTriggerStep
    | GroupStep
  )[];
  [k: string]: unknown;
}
/**
 * Environment variables for this step
 */
export interface Env {
  [k: string]: unknown;
}
/**
 * Query rules to target specific agents
 */
export interface AgentsObject {
  [k: string]: unknown;
}
export interface BlockStep {
  allow_dependency_failure?: AllowDependencyFailure;
  /**
   * The label of the block step
   */
  block?: string;
  /**
   * The state that the build is set to when the build is blocked by this block step
   */
  blocked_state?: "passed" | "failed" | "running";
  branches?: Branches;
  depends_on?: DependsOn;
  fields?: Fields;
  if?: If;
  key?: Key;
  identifier?: Key;
  /**
   * @deprecated
   * A unique identifier for a step, must not resemble a UUID
   */
  id?: string;
  /**
   * The label of the block step
   */
  label?: string;
  /**
   * The label of the block step
   */
  name?: string;
  prompt?: Prompt;
  type?: "block";
}
export interface NestedBlockStep {
  block?: BlockStep;
}
export interface InputStep {
  allow_dependency_failure?: AllowDependencyFailure;
  /**
   * The label of the input step
   */
  input?: string;
  branches?: Branches;
  depends_on?: DependsOn;
  fields?: Fields;
  if?: If;
  key?: Key;
  identifier?: Key;
  /**
   * @deprecated
   * A unique identifier for a step, must not resemble a UUID
   */
  id?: string;
  /**
   * The label of the input step
   */
  label?: string;
  /**
   * The label of the input step
   */
  name?: string;
  prompt?: Prompt;
  type?: "input";
}
export interface NestedInputStep {
  input?: InputStep;
}
export interface CommandStep {
  agents?: Agents;
  allow_dependency_failure?: AllowDependencyFailure;
  /**
   * The glob path/s of artifacts to upload once this step has finished running
   */
  artifact_paths?: string | string[];
  branches?: Branches;
  cache?: Cache;
  cancel_on_build_failing?: CancelOnBuildFailing;
  /**
   * The commands to run on the agent
   */
  command?: string[] | string;
  /**
   * The commands to run on the agent
   */
  commands?: string[] | string;
  /**
   * The maximum number of jobs created from this step that are allowed to run at the same time. If you use this attribute, you must also define concurrency_group.
   */
  concurrency?: number;
  /**
   * A unique name for the concurrency group that you are creating with the concurrency attribute
   */
  concurrency_group?: string;
  /**
   * Control command order, allowed values are 'ordered' (default) and 'eager'.  If you use this attribute, you must also define concurrency_group and concurrency.
   */
  concurrency_method?: "ordered" | "eager";
  depends_on?: DependsOn;
  env?: Env;
  if?: If;
  key?: Key;
  identifier?: Key;
  /**
   * @deprecated
   * A unique identifier for a step, must not resemble a UUID
   */
  id?: string;
  label?: Label;
  /**
   * The signature of the command step, generally injected by agents at pipeline upload
   */
  signature?: {
    /**
     * The algorithm used to generate the signature
     */
    algorithm?: string;
    /**
     * The signature value, a JWS compact signature with a detached body
     */
    value?: string;
    /**
     * The fields that were signed to form the signature value
     */
    signed_fields?: string[];
    [k: string]: unknown;
  };
  matrix?:
    | MatrixElement[]
    | {
        setup:
          | MatrixElement[]
          | {
              /**
               * List of elements for this Build Matrix dimension
               */
              [k: string]: MatrixElement[];
            };
        /**
         * List of Build Matrix adjustments
         */
        adjustments?: {
          with:
            | MatrixElement[]
            | {
                /**
                 * Build Matrix dimension element
                 */
                [k: string]: string;
              };
          skip?: Skip;
          soft_fail?: SoftFail;
          [k: string]: unknown;
        }[];
        [k: string]: unknown;
      };
  name?: Label;
  /**
   * Array of notification options for this step
   */
  notify?: (
    | ("github_check" | "github_commit_status")
    | {
        basecamp_campfire?: string;
        if?: If;
      }
    | {
        slack?:
          | string
          | {
              channels?: string[];
              message?: string;
            };
        if?: If;
      }
    | {
        github_commit_status?: {
          /**
           * GitHub commit status name
           */
          context?: string;
        };
        if?: If;
      }
    | {
        github_check?: {
          /**
           * GitHub commit status name
           */
          context?: string;
          [k: string]: unknown;
        };
        if?: If;
      }
  )[];
  /**
   * The number of parallel jobs that will be created based on this step
   */
  parallelism?: number;
  plugins?:
    | (
        | string
        | {
            [k: string]: unknown;
          }
      )[]
    | {
        [k: string]: unknown;
      };
  soft_fail?: SoftFail;
  /**
   * The conditions for retrying this step.
   */
  retry?: {
    /**
     * Whether to allow a job to retry automatically. If set to true, the retry conditions are set to the default value.
     */
    automatic?: (true | false | "true" | "false") | AutomaticRetry | AutomaticRetry[];
    /**
     * Whether to allow a job to be retried manually
     */
    manual?:
      | (true | false | "true" | "false")
      | {
          /**
           * Whether or not this job can be retried manually
           */
          allowed?: true | false | "true" | "false";
          /**
           * Whether or not this job can be retried after it has passed
           */
          permit_on_passed?: true | false | "true" | "false";
          /**
           * A string that will be displayed in a tooltip on the Retry button in Buildkite. This will only be displayed if the allowed attribute is set to false.
           */
          reason?: string;
        };
  };
  skip?: Skip;
  /**
   * The number of minutes to time out a job
   */
  timeout_in_minutes?: number;
  type?: "script" | "command" | "commands";
  /**
   * Priority of the job, higher priorities are assigned to agents
   */
  priority?: number;
}
export interface AutomaticRetry {
  /**
   * The exit status number that will cause this job to retry
   */
  exit_status?: "*" | number | number[];
  /**
   * The number of times this job can be retried
   */
  limit?: number;
  /**
   * The exit signal, if any, that may be retried
   */
  signal?: string;
  /**
   * The exit signal reason, if any, that may be retried
   */
  signal_reason?: "*" | "none" | "agent_refused" | "agent_stop" | "cancel" | "process_run_error" | "signature_rejected";
}
export interface NestedCommandStep {
  command?: CommandStep;
  commands?: CommandStep;
  script?: CommandStep;
}
export interface WaitStep {
  allow_dependency_failure?: AllowDependencyFailure;
  branches?: Branches;
  /**
   * Continue to the next steps, even if the previous group of steps fail
   */
  continue_on_failure?: true | false | "true" | "false";
  depends_on?: DependsOn;
  if?: If;
  key?: Key;
  /**
   * Waits for previous steps to pass before continuing
   */
  label?: string | null;
  /**
   * Waits for previous steps to pass before continuing
   */
  name?: string | null;
  identifier?: Key;
  /**
   * @deprecated
   * A unique identifier for a step, must not resemble a UUID
   */
  id?: string;
  type?: "wait" | "waiter";
  /**
   * Waits for previous steps to pass before continuing
   */
  wait?: string | null;
  waiter?: string | null;
}
export interface NestedWaitStep {
  wait?: WaitStep1;
  waiter?: WaitStep;
}
/**
 * Waits for previous steps to pass before continuing
 */
export interface WaitStep1 {
  allow_dependency_failure?: AllowDependencyFailure;
  branches?: Branches;
  /**
   * Continue to the next steps, even if the previous group of steps fail
   */
  continue_on_failure?: true | false | "true" | "false";
  depends_on?: DependsOn;
  if?: If;
  key?: Key;
  /**
   * Waits for previous steps to pass before continuing
   */
  label?: string | null;
  /**
   * Waits for previous steps to pass before continuing
   */
  name?: string | null;
  identifier?: Key;
  /**
   * @deprecated
   * A unique identifier for a step, must not resemble a UUID
   */
  id?: string;
  type?: "wait" | "waiter";
  /**
   * Waits for previous steps to pass before continuing
   */
  wait?: string | null;
  waiter?: string | null;
}
export interface TriggerStep {
  allow_dependency_failure?: AllowDependencyFailure;
  /**
   * Whether to continue the build without waiting for the triggered step to complete
   */
  async?: true | false | "true" | "false";
  branches?: Branches;
  /**
   * Properties of the build that will be created when the step is triggered
   */
  build?: {
    /**
     * The branch for the build
     */
    branch?: string;
    /**
     * The commit hash for the build
     */
    commit?: string;
    env?: Env;
    /**
     * The message for the build (supports emoji)
     */
    message?: string;
    /**
     * Meta-data for the build
     */
    meta_data?: {
      [k: string]: unknown;
    };
  };
  depends_on?: DependsOn;
  if?: If;
  key?: Key;
  identifier?: Key;
  /**
   * @deprecated
   * A unique identifier for a step, must not resemble a UUID
   */
  id?: string;
  label?: Label;
  name?: Label;
  type?: "trigger";
  /**
   * The slug of the pipeline to create a build
   */
  trigger: string;
  skip?: Skip;
  /**
   * The conditions for marking the step as a soft-fail.
   */
  soft_fail?: true | false | "true" | "false";
}
export interface NestedTriggerStep {
  trigger?: TriggerStep;
}
export interface GroupStep {
  depends_on?: DependsOn;
  /**
   * The name to give to this group of steps
   */
  group: string | null;
  if?: If;
  key?: Key;
  identifier?: Key;
  /**
   * @deprecated
   * A unique identifier for a step, must not resemble a UUID
   */
  id?: string;
  /**
   * The name to give to this group of steps
   */
  label?: string | null;
  /**
   * The name to give to this group of steps
   */
  name?: string | null;
  allow_dependency_failure?: AllowDependencyFailure;
  notify?: BuildNotify;
  skip?: Skip;
  /**
   * A list of steps
   *
   * @minItems 1
   */
  steps: [
    (
      | BlockStep
      | NestedBlockStep
      | StringBlockStep
      | InputStep
      | NestedInputStep
      | StringInputStep
      | CommandStep
      | NestedCommandStep
      | WaitStep
      | NestedWaitStep
      | StringWaitStep
      | TriggerStep
      | NestedTriggerStep
    ),
    ...(
      | BlockStep
      | NestedBlockStep
      | StringBlockStep
      | InputStep
      | NestedInputStep
      | StringInputStep
      | CommandStep
      | NestedCommandStep
      | WaitStep
      | NestedWaitStep
      | StringWaitStep
      | TriggerStep
      | NestedTriggerStep
    )[]
  ];
}
